# db.py
import psycopg2
import os
from dotenv import load_dotenv
import streamlit as st
from psycopg2 import sql
import pandas as pd
import re

# Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…ÙƒØªØ¨Ø© Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù‡Ø¬Ø±ÙŠ
try:
    from hijri_converter import Hijri
except ImportError:
    st.warning("âš ï¸ Ù…ÙƒØªØ¨Ø© hijri-converter ØºÙŠØ± Ù…ØªÙˆÙØ±Ø©. Ø§Ù„ØªÙˆØ§Ø±ÙŠØ® Ø§Ù„Ù‡Ø¬Ø±ÙŠØ© Ù‚Ø¯ Ù„Ø§ ÙŠØªÙ… ØªØ­ÙˆÙŠÙ„Ù‡Ø§ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­. ÙŠØ±Ø¬Ù‰ ØªØ«Ø¨ÙŠØªÙ‡Ø§ Ø¹Ø¨Ø± 'pip install hijri-converter'.")
    Hijri = None

load_dotenv()
DB_URL = os.getenv("DATABASE_URL")

# Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (Ù„Ø§ ØªØªØ¶Ù…Ù† "Ù…Ø¤Ø´Ø± Ø§Ù„ØªØ´ØªØª")
DB_COLUMN_NAMES = [
    "Ø±Ù‚Ù… Ø§Ù„ØµØ§Ø¯Ø±", "ØªØ§Ø±ÙŠØ® Ø§Ù„ØµØ§Ø¯Ø±", "Ø§Ø³Ù… Ø§Ù„Ù…Ø´ØªØ¨Ù‡ Ø¨Ù‡", "Ø±Ù‚Ù… Ø§Ù„Ù‡ÙˆÙŠØ©",
    "Ø§Ù„Ø¬Ù†Ø³ÙŠØ©", "ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…ÙŠÙ„Ø§Ø¯ Ø§Ù„ÙˆØ§ÙØ¯", "ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¯Ø®ÙˆÙ„", "Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠØ©",
    "Ø§Ù„Ù…Ù‡Ù†Ø©", "Ø±Ù‚Ù… Ø§Ù„Ø¬ÙˆØ§Ù„", "Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©", "Ø±ØµÙŠØ¯ Ø§Ù„Ø­Ø³Ø§Ø¨", "Ø§Ù„Ø¯Ø®Ù„ Ø§Ù„Ø³Ù†ÙˆÙŠ",
    "Ø±Ù‚Ù… Ø§Ù„ÙˆØ§Ø±Ø¯", "ØªØ§Ø±ÙŠØ® Ø§Ù„ÙˆØ§Ø±Ø¯", "Ø±Ù‚Ù… ØµØ§Ø­Ø¨ Ø§Ù„Ø¹Ù…Ù„/ Ø§Ù„Ø³Ø¬Ù„ Ø§Ù„ØªØ¬Ø§Ø±ÙŠ",
    "Ø³Ø¨Ø¨ Ø§Ù„Ø§Ø´ØªØ¨Ø§Ù‡", "ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¯Ø§Ø±Ø³Ø© Ù…Ù†", "ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¯Ø±Ø§Ø³Ø© Ø§Ù„Ù‰",
    "Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø¥ÙŠØ¯Ø§Ø¹ Ø§Ù„Ø¯Ø±Ø§Ø³Ø©",
    "Ø§Ø³Ù… Ø§Ù„Ù…Ù„Ù",
    "ÙˆÙ‚Øª Ø§Ù„Ø§Ø³ØªØ®Ù„Ø§Øµ"
]

DATA_KEYS = DB_COLUMN_NAMES

# Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø¥Ù„Ù‰ Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©
def arabic_to_english_numbers(text):
    if not isinstance(text, str):
        return text
    
    arabic_map = {
        'Ù ': '0', 'Ù¡': '1', 'Ù¢': '2', 'Ù£': '3', 'Ù¤': '4',
        'Ù¥': '5', 'Ù¦': '6', 'Ù§': '7', 'Ù¨': '8', 'Ù©': '9'
    }
    return text.translate(str.maketrans(arabic_map))


def connect_db():
    """ÙŠÙ†Ø´Ø¦ Ø§ØªØµØ§Ù„Ù‹Ø§ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª."""
    try:
        if not DB_URL:
            st.error("âŒ Ù…ØªØºÙŠØ± DATABASE_URL ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯. ÙŠØ±Ø¬Ù‰ Ù…Ø±Ø§Ø¬Ø¹Ø© Ù…Ù„Ù .env")
            return None
        conn = psycopg2.connect(DB_URL, sslmode='require')
        return conn
    except Exception as e:
        st.error(f"âŒ ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: {e}")
        return None


def clean_data_type(key, value):
    """ØªÙ†Ø¸ÙŠÙ ÙˆØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù‚ÙŠÙ… Ø¥Ù„Ù‰ ØªÙ†Ø³ÙŠÙ‚Ø§Øª ØµØ§Ù„Ø­Ø© Ù„Ù€ PostgreSQL."""
    
    # 1. Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„ÙØ§Ø±ØºØ©
    if value is None or value == 'ØºÙŠØ± Ù…ØªÙˆÙØ±' or value == '' or pd.isna(value):
        return None

    # 2. ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ø§Ù„Ø±Ù‚Ù…ÙŠØ© (NUMERIC) - ØªÙ… Ø­Ù„ Ù…Ø´ÙƒÙ„Ø© Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„ÙƒØ¨ÙŠØ±Ø© ÙˆØ§Ù„ØµØºÙŠØ±Ø© Ù‡Ù†Ø§
    numeric_fields = ["Ø±ØµÙŠØ¯ Ø§Ù„Ø­Ø³Ø§Ø¨", "Ø§Ù„Ø¯Ø®Ù„ Ø§Ù„Ø³Ù†ÙˆÙŠ", "Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø¥ÙŠØ¯Ø§Ø¹ Ø§Ù„Ø¯Ø±Ø§Ø³Ø©"]
    if key in numeric_fields:
        try:
            cleaned_value = arabic_to_english_numbers(str(value))
            temp_val = re.sub(r'[^\d\.,-]', '', cleaned_value)

            last_separator_index = max(temp_val.rfind('.'), temp_val.rfind(','))
            
            if last_separator_index != -1:
                integer_part = temp_val[:last_separator_index]
                decimal_part = temp_val[last_separator_index+1:]
                
                integer_part = re.sub(r'[,\.]', '', integer_part) 
                
                # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø¨Ø¹Ø¯ Ø¢Ø®Ø± ÙØ§ØµÙ„Ø© Ø£ÙƒØ«Ø± Ù…Ù† Ø±Ù‚Ù…ÙŠÙ† (ÙØ§ØµÙ„ Ø£Ù„ÙˆÙ)ØŒ Ù†Ø¹ØªØ¨Ø±Ù‡ Ø±Ù‚Ù…Ù‹Ø§ ØµØ­ÙŠØ­Ù‹Ø§ ÙƒØ¨ÙŠØ±Ø§Ù‹
                if len(decimal_part) > 2:
                    final_val = integer_part + decimal_part
                    final_val = re.sub(r'[^\d\.-]', '', final_val)
                    return float(final_val)
                else:
                    # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø±Ù‚Ù…ÙŠÙ† Ø£Ùˆ Ø£Ù‚Ù„ (ÙØ§ØµÙ„ Ø¹Ø´Ø±ÙŠ)ØŒ Ù†Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù†Ù‚Ø·Ø© ÙƒÙØ§ØµÙ„ Ø¹Ø´Ø±ÙŠ
                    final_val = f"{integer_part}.{decimal_part}"
                    final_val = re.sub(r'[^\d\.-]', '', final_val)
                    return float(final_val)
            else:
                final_val = re.sub(r'[^\d\.-]', '', temp_val)
                if not final_val:
                    return None
                return float(final_val)

        except ValueError:
            return None
            
    # 3. ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠØ© (DATE)
    date_fields = ["ØªØ§Ø±ÙŠØ® Ø§Ù„ØµØ§Ø¯Ø±", "ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…ÙŠÙ„Ø§Ø¯ Ø§Ù„ÙˆØ§ÙØ¯", "ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¯Ø®ÙˆÙ„", "ØªØ§Ø±ÙŠØ® Ø§Ù„ÙˆØ§Ø±Ø¯", "ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¯Ø§Ø±Ø³Ø© Ù…Ù†", "ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¯Ø±Ø§Ø³Ø© Ø§Ù„Ù‰"]
    if key in date_fields:
        
        date_str = arabic_to_english_numbers(str(value))
        clean_str_base = re.sub(r'[^\d/\-.]', '', date_str).strip()
        
        # Ø£. Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ­ÙˆÙŠÙ„ Ù…ÙŠÙ„Ø§Ø¯ÙŠ Ù…Ø¨Ø§Ø´Ø±
        try:
            date_obj = pd.to_datetime(clean_str_base, errors='coerce', dayfirst=False)
            if pd.notna(date_obj) and date_obj.year > 1800:
                return date_obj.date()
        except Exception:
            pass
        
        # Ø¨. Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù‡Ø¬Ø±ÙŠ
        if Hijri:
            try:
                # ğŸ’¡ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø­Ø§Ø³Ù…: ØªØµÙÙŠØ© Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„ÙØ§Ø±ØºØ© Ù‚Ø¨Ù„ Ø§Ù„ØªØ­ÙˆÙŠÙ„
                parts = [p for p in re.split(r'[/\-.]', clean_str_base) if p.strip()] 
                
                if len(parts) == 3:
                    try:
                        y_str, m_str, d_str = parts
                        y = int(re.sub(r'[^\d]', '', y_str))
                        m = int(re.sub(r'[^\d]', '', m_str))
                        d = int(re.sub(r'[^\d]', '', d_str))
                    except ValueError:
                         return None # ÙØ´Ù„ Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ø£Ø±Ù‚Ø§Ù…
                    
                    # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø´Ø§Ø¦Ø¹Ø© ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø³Ù†Ø© Ù¡Ù¤Ù¤x 
                    if y >= 400 and y <= 500:
                        y += 1000 
                    elif y >= 900 and y <= 999:
                        y = 1400 + (y % 100)
                        
                    
                    if y > 1300 and y < 1500:
                        # Ø¥Ø¶Ø§ÙØ© ØªØ­Ù‚Ù‚ Ø¨Ø³ÙŠØ· Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„ÙØ§Ø¯Ø­Ø© ÙÙŠ Ø§Ù„Ù…ÙƒØªØ¨Ø©
                        if 1 <= m <= 12 and 1 <= d <= 30:
                            gregorian_date = Hijri(y, m, d).to_gregorian()
                            return gregorian_date.date()
                    
            except Exception:
                pass 

        return None

    # 4. Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø£Ø®Ø±Ù‰ (VARCHAR/TEXT)
    return value


def save_to_db(extracted_data):
    """ÙŠØ­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ù„ØµØ© Ø¥Ù„Ù‰ Ø¬Ø¯ÙˆÙ„ ØªÙ‚Ø§Ø±ÙŠØ±_Ø§Ù„Ø§Ø´ØªØ¨Ø§Ù‡."""
    conn = connect_db()
    if not conn:
        return False
    
    try:
        cur = conn.cursor()
        
        insert_columns = []
        insert_values = []
        
        for key in DATA_KEYS:
            value = extracted_data.get(key)
            
            processed_value = clean_data_type(key, value)

            insert_columns.append(sql.Identifier(key))
            insert_values.append(sql.Literal(processed_value))
            

        columns_sql = sql.SQL(', ').join(insert_columns)
        values_list = sql.SQL(', ').join(insert_values)

        insert_query = sql.SQL("""
            INSERT INTO public.ØªÙ‚Ø§Ø±ÙŠØ±_Ø§Ù„Ø§Ø´ØªØ¨Ø§Ù‡ ({columns})
            VALUES ({values})
        """).format(
            columns=columns_sql,
            values=values_list
        )
        
        cur.execute(insert_query)
        
        conn.commit()
        cur.close()
        conn.close()
        return True
    except Exception as e:
        st.error(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: {e}")
        if conn:
            conn.rollback()
            conn.close()
        return False

def fetch_all_reports():
    """ÙŠØ¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø³Ø¬Ù„Ø§Øª Ù…Ù† Ø¬Ø¯ÙˆÙ„ ØªÙ‚Ø§Ø±ÙŠØ±_Ø§Ù„Ø§Ø´ØªØ¨Ø§Ù‡."""
    conn = connect_db()
    if not conn:
        return None, None

    try:
        cur = conn.cursor()
        
        select_query = sql.SQL('SELECT * FROM public.ØªÙ‚Ø§Ø±ÙŠØ±_Ø§Ù„Ø§Ø´ØªØ¨Ø§Ù‡')
        
        cur.execute(select_query)
        
        column_names = [desc[0] for desc in cur.description]
        records = cur.fetchall()
        
        cur.close()
        conn.close()
        
        return records, column_names

    except Exception as e:
        st.error(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: {e}")
        if conn:
            conn.close()
        return None, None
